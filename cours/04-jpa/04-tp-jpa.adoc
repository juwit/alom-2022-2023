:source-highlighter: pygments
:prewrap!:

:icons: font

:toc: left
:toclevels: 4

:linkattrs:

:sectlinks:
:sectanchors:
:sectnums:

:experimental:

= ALOM - TP 4 - JPA & Repositories

== Pr√©sentation et objectifs

image::images/architecture.svg[inline]

Le but est de continuer le d√©veloppement de notre architecture "√† la microservice".

Pour rappel, dans cette architecture, chaque composant a son r√¥le pr√©cis :

* la servlet re√ßoit les requ√™tes HTTP, et les envoie au bon controller (r√¥le de point d'entr√©e de l'application)
* le controlleur impl√©mente une m√©thode Java par route HTTP, r√©cup√®re les param√®tres, et appelle le service (r√¥le de routage)
* le service impl√©mente le m√©tier de notre micro-service
* le repository repr√©sente les acc√®s aux donn√©es (avec potentiellement une base de donn√©es)

Et pour s'amuser un peu, nous allons r√©aliser un micro-service qui nous renvoie des donn√©es sur les dresseurs de Pokemon !

Nous allons d√©velopper :

1. un repository d'acc√®s aux donn√©es de Trainers (√† partir d'une base de donn√©es)
2. un service d'acc√®s aux donn√©es
3. annoter ces composants avec les annotations de Spring et les tester
4. cr√©er un controlleur spring pour g√©rer nos requ√™tes HTTP / REST
5. charger quelques donn√©es

[TIP]
====
Nous repartons de z√©ro pour ce TP !
====

== Github

Identifiez vous sur Github, et cliquez sur le lien suivant pour cr√©er votre repository git: https://classroom.github.com/a/hxLZz1b5[Github classroom,window="_blank"]

Clonez ensuite votre repository git sur votre poste !

[NOTE]
====
A partir de ce TP, votre repository nouvellement cr√©√© contiendra un squelette de projet contenant:

* un fichier `pom.xml` basique
* l'arborescence projet:
** `src/main/java`
** `src/main/resources`
** `src/test/java`
** `src/test/resources`

image::images/arbo.png[]
====

== Le `pom.xml`

Modifiez le fichier pom.xml √† la racine du projet

[source,xml,linenums]
----
<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.miage.alom</groupId>
    <artifactId>trainer-api</artifactId> <!--1-->
    <version>0.1.0</version>
    <packaging>jar</packaging> <!--2-->

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.4</version> <!--2-->
    </parent>

    <properties>
        <maven.compiler.source>17</maven.compiler.source> <!--3-->
        <maven.compiler.target>17</maven.compiler.target> <!--3-->
    </properties>

    <dependencies>

        <!-- spring-boot web-->
        <dependency>
            <groupId>org.springframework.boot</groupId> <!--2-->
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- testing --> <!--4-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
        </dependency>

    </dependencies>

     <build> <!--5-->
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
        <pluginManagement>
            <plugins>
                <plugin>
                    <artifactId>maven-surefire-plugin</artifactId>
                    <version>2.22.2</version>
                </plugin>
            </plugins>
        </pluginManagement>
    </build>

</project>
----
<1> Modifiez votre `artifactId`
<2> Cette fois, on utilise directement `spring-boot` pour construire un `jar`
<3> en java 17...
<4> On positionne https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html[spring-boot-starter-test,window="_blank"]
qui nous importe JUnit et Mockito !
<5> La partie build utilise le `spring-boot-maven-plugin`

Pour pr√©parer les d√©veloppements, on va √©galement tout de suite cr√©er quelques
packages Java qui vont mat√©rialiser notre architecture applicative.

Cr√©er les packages suivants:

* `com.miage.alom.trainers.bo` : va contenir les objets m√©tier de notre application
* `com.miage.alom.trainers.controller` : va contenir la configuration de notre application
* `com.miage.alom.trainers.repository` : va contenir les repository de notre application
* `com.miage.alom.trainers.service` : va contenir les services de notre application

Notre projet est pr√™t !

== Le repository

Lors du TP pr√©c√©dent, nous avions √©crit un repository qui utilisait un fichier `JSON` comme source de donn√©es.

Cette semaine, nous utiliserons directement une base de donn√©es, embarqu√©e dans un premier temps.

NOTE: Nous commen√ßons les d√©veloppements avec une base de donn√©es embarqu√©e, puis nous testerons ensuite une base de donn√©es manag√©e sur un cloud public.

Cette base de donn√©es est http://www.h2database.com/html/main.html[H2].
H2 est √©crit en Java, impl√©mente le standard http://www.h2database.com/html/grammar.html[SQL], et peut fonctionner
directement en m√©moire !

=== L'ajout de la d√©pendance spring-boot-data-jpa et H2

Ajoutez les d√©pendance suivantes dans votre `pom.xml`

.pom.xml
[source,xml,linenums]
----
<dependency> <!--1-->
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency> <!--2-->
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>test</scope>
</dependency>
----
<1> spring-boot-starter-data-jpa nous permet d'utiliser les repositories JPA !
<2> La base de donn√©es H2, en scope test (nous utiliserons une vraie BDD en production !)

=== Les business objects

Nous allons manipuler, dans ce microservice, des dresseurs de Pokemon (Trainer), ainsi que leur √©quipe de Pokemons pr√©f√©r√©e
(id de pok√©mon type + niveau).

Nous allons donc commencer par √©crire deux classes Java pour repr√©senter nos donn√©es : `Trainer` et `Pokemon`

.src/main/java/com/miage/alom/trainers/bo/Trainer.java
[source,java,linenums]
----
// TODO
public class Trainer { //<1>

    private String name; //<2>

    private List<Pokemon> team; //<3>

    public Trainer() {
    }

    public Trainer(String name) {
        this.name = name;
    }

    [...] //<4>
}
----
<1> Notre classe de dresseur de Pokemon
<2> Son nom (qui servira d'identifiant en base de donn√©es :) )
<3> La liste de ses pokemons
<4> Les getters/setters habituels (√† g√©n√©rer avec kbd:[Alt+Inser] !)

[NOTE]
====
Nous ne pouvons pas utiliser les `record` de Java 17 pour repr√©senter les Trainers/Pokemon.
Les _Entity_ JPA doivent:

* √™tre des classes non `final`
* avoir un constructeur `public` sans argument
* les attributs doivent √™tre non `final`

Les records ne respectent pas ces conditions, et donc on ne peut pas les utiliser pour le moment üòî.
====

.src/main/java/com/miage/alom/bo/Pokemon.java
[source,java,linenums]
----
// TODO
public class Pokemon {

    private int pokemonTypeId; // <1>

    private int level; // <2>

    public Pokemon() {
    }

    public Pokemon(int pokemonTypeId, int level) {
        this.pokemonTypeId = pokemonTypeId;
        this.level = level;
    }

    [...] // <4>
}
----
<1> le num√©ro de notre Pokemon dans le Pokedex (r√©f√©rence au service pokemon-type-api !)
<2> le niveau de notre Pokemon !

=== Les test unitaires

Impl√©mentez les tests unitaires suivant :

.src/test/java/com/miage/alom/trainers/bo/TrainerTest.java
[source,java,linenums]
----
package com.miage.alom.trainers.bo;

import org.junit.jupiter.api.Test;

import javax.persistence.*;

import static org.junit.jupiter.api.Assertions.*;

class TrainerTest {

    @Test
    void trainer_shouldBeAnEntity(){
        assertNotNull(Trainer.class.getAnnotation(Entity.class)); //<1>
    }

    @Test
    void trainerName_shouldBeAnId() throws NoSuchFieldException {
        assertNotNull(Trainer.class.getDeclaredField("name").getAnnotation(Id.class)); //<2>
    }

    @Test
    void trainerTeam_shouldBeAElementCollection() throws NoSuchFieldException {
        assertNotNull(Trainer.class.getDeclaredField("team").getAnnotation(ElementCollection.class)); //<3>
    }

}
----
<1> Notre classe `Trainer` doit √™tre annot√©e `@Entity` pour √™tre reconnue par JPA
<2> Chaque classe annot√©e `@Entity` doit d√©clarer un de ses champs comme √©tant un `@Id`. Dans le cas du `Trainer`,
le champ `name` est id√©al
<3> La relation entre `Trainer` et `Pokemon` doit √©galement √™tre annot√©e. Ici, un `Trainer` poss√®de une collection de `Pokemon`.

.src/test/java/com/miage/alom/trainers/bo/PokemonTest.java
[source,java,linenums]
----
class PokemonTest {

    @Test
    void pokemon_shouldBeAnEmbeddable(){
        assertNotNull(Pokemon.class.getAnnotation(Embeddable.class)); //<1>
    }

}
----
<1> Notre classe `Pokmeon` doit aussi √™tre annot√©e `@Embeddable` pour √™tre reconnue par JPA

.src/test/java/com/miage/alom/trainers/repository/TrainerRepositoryTest.java
[source,java,linenums]
----
package com.miage.alom.trainers.repository;

import [...]

import static org.junit.jupiter.api.Assertions.*;

@DataJpaTest //<1>
class TrainerRepositoryTest {

    @Autowired //<2>
    private TrainerRepository repository;

    @Test
    void trainerRepository_shouldExtendsCrudRepository() throws NoSuchMethodException {
        assertTrue(CrudRepository.class.isAssignableFrom(TrainerRepository.class)); //<3>
    }

    @Test
    void trainerRepositoryShouldBeInstanciedBySpring(){
        assertNotNull(repository);
    }

    @Test
    void testSave(){ //<4>
        var ash = new Trainer("Ash");

        repository.save(ash);

        var saved = repository.findById(ash.getName()).orElse(null);

        assertEquals("Ash", saved.getName());
    }

    @Test
    void testSaveWithPokemons(){ //<5>
        var misty = new Trainer("Misty");
        var staryu = new Pokemon(120, 18);
        var starmie = new Pokemon(121, 21);
        misty.setTeam(List.of(staryu, starmie));

        repository.save(misty);

        var saved = repository.findById(misty.getName()).orElse(null);

        assertEquals("Misty", saved.getName());
        assertEquals(2, saved.getTeam().size());
    }

}
----
<1> On utilise un `@DataJpaTest` test, qui va d√©marrer spring (uniquement la partie gestion des repositories et base de donn√©es).
<2> On utilise l'injection de d√©pendances spring dans notre test !
<3> On valide que notre repository h√©rite du `CrudRepository` propos√© par spring.
<4> On test la sauvegarde simple
<5> et la sauvegarde avec des objets en cascade !

[NOTE]
Ce type de test, appel√© test d'int√©gration, a pour but de valider que l'application se contruit bien.
Le d√©marrage de spring √©tant plus long que le simple couple JUnit/Mockito, on utilise souvent ces tests uniquement sur
la partie repository

[NOTE]
Notre test sera ex√©cut√© avec une instance de base de donn√©es H2 instanci√©e √† la vol√©e !

=== L'ex√©cution de notre test

Pour s'ex√©cuter, notre test unitaire a besoin d'une application Spring-Boot !

Impl√©mentez la classe suivante :

.src/main/java/com/miage/alom/trainers/TrainerApi.java
[source,java,linenums]
----
package com.miage.alom.trainers;

import [...]

@SpringBootApplication //<1>
public class TrainerApi {

    public static void main(String... args){ //<2>
        SpringApplication.run(TrainerApi.class, args);
    }

}

----
<1> On annote la classe comme √©tant le point d'entr√©e de notre application
<2> On impl√©mente un main pour d√©marrer notre application !

=== L'impl√©mentation

Ajouter l'interface du TrainerRepository !

.src/main/java/com/miage/alom/trainers/repository/TrainerRepository.java
[source,java,linenums]
----
// TODO
public interface TrainerRepository {
}
----

[WARNING]
Attention, ici, nous ne d√©velopperons pas l'impl√©mentation du repository !
C'est spring qui se chargera de nous en cr√©er une instance √† l'ex√©cution !

[TIP]
====
Pour vous aider, voici deux liens int√©ressants :

* La documentation officielle de spring-data : https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories
* Et un tutoriel officiel : https://spring.io/guides/gs/accessing-data-jpa/
====

== Le service

Maintenant que nous avons un repository fonctionnel, il est temps de d√©velopper
un service qui consomme notre repository !

=== Le test unitaire

.src/test/java/com/miage/alom/trainers/service/TrainerServiceImplTest.java
[source,java,linenums]
----
class TrainerServiceImplTest {

    @Test
    void getAllTrainers_shouldCallTheRepository() {
        var trainerRepo = mock(TrainerRepository.class);
        var trainerService = new TrainerServiceImpl(trainerRepo);

        trainerService.getAllTrainers();

        verify(trainerRepo).findAll();
    }

    @Test
    void getTrainer_shouldCallTheRepository() {
        var trainerRepo = mock(TrainerRepository.class);
        var trainerService = new TrainerServiceImpl(trainerRepo);

        trainerService.getTrainer("Ash");

        verify(trainerRepo).findById("Ash");
    }

    @Test
    void createTrainer_shouldCallTheRepository() {
        var trainerRepo = mock(TrainerRepository.class);
        var trainerService = new TrainerServiceImpl(trainerRepo);

        var ash = new Trainer();
        trainerService.createTrainer(ash);

        verify(trainerRepo).save(ash);
    }

}
----

=== L'impl√©mentation

L'interface Java

.src/main/java/com/miage/alom/trainers/service/TrainerService.java
[source,java,linenums]
----

public interface TrainerService {

    Iterable<Trainer> getAllTrainers();
    Trainer getTrainer(String name);
    Trainer createTrainer(Trainer trainer);
}
----

et son impl√©mentation

.src/main/java/com/miage/alom/trainers/service/TrainerServiceImpl.java
[source,java,linenums]
----
// TODO
public class TrainerServiceImpl implements TrainerService { //<1>

    private TrainerRepository trainerRepository;

    public TrainerServiceImpl(TrainerRepository trainerRepository) {
        this.trainerRepository = trainerRepository;
    }

    @Override
    public Iterable<Trainer> getAllTrainers() {
        // TODO
    }

    @Override
    public Trainer getTrainer(String name) {
        // TODO
    }

    @Override
    public Trainer createTrainer(Trainer trainer) {
        // TODO
    }
}
----
<1> √† impl√©menter !

[NOTE]
Comme nous n'avons pas la main sur l'impl√©mentation du repository (spring le cr√©e dynamiquement), l'utilisation
de l'injection de d√©pendances devient primordiale !

== Le controlleur

Impl√©mentons un Controlleur afin d'exposer nos Trainers en HTTP/REST/JSON.

=== Le test unitaire

Le controlleur est simple et s'inpire de ce que nous avons fait au TP pr√©c√©dent.

.src/test/java/com/miage/alom/trainers/controller/TrainerControllerTest.java
[source,java,linenums]
----
class TrainerControllerTest {

    @Mock
    private TrainerService trainerService;

    @InjectMocks
    private TrainerController trainerController;

    @BeforeEach
    void setup(){
        MockitoAnnotations.initMocks(this);
    }

    @Test
    void getAllTrainers_shouldCallTheService() {
        trainerController.getAllTrainers();

        verify(trainerService).getAllTrainers();
    }

    @Test
    void getTrainer_shouldCallTheService() {
        trainerController.getTrainer("Ash");

        verify(trainerService).getTrainer("Ash");
    }
}
----

=== L'impl√©mentation

Compl√©ter l'impl√©mentation du controller :

.src/main/java/com/miage/alom/trainers/controller/TrainerController.java
[source,java,linenums]
----
public class TrainerController {

    private final TrainerService trainerService;

    TrainerController(TrainerService trainerService){
        this.trainerService = trainerService;
    }

    Iterable<Trainer> getAllTrainers(){
        // TODO <1>
    }

    Trainer getTrainer(String name){
        // TODO <1>
    }

}

----
<1> Impl√©mentez !

=== L'ajout des annotations Spring

Ajoutez les m√©thodes de test suivantes dans la classe `TrainerControllerTest` :

.TrainerControllerTest.java
[source,java,linenums]
----
@Test
void trainerController_shouldBeAnnotated(){
    var controllerAnnotation =
            TrainerController.class.getAnnotation(RestController.class);
    assertNotNull(controllerAnnotation);

    var requestMappingAnnotation =
            TrainerController.class.getAnnotation(RequestMapping.class);
    assertArrayEquals(new String[]{"/trainers"}, requestMappingAnnotation.value());
}

@Test
void getAllTrainers_shouldBeAnnotated() throws NoSuchMethodException {
    var getAllTrainers =
            TrainerController.class.getDeclaredMethod("getAllTrainers");
    var getMapping = getAllTrainers.getAnnotation(GetMapping.class);

    assertNotNull(getMapping);
    assertArrayEquals(new String[]{"/"}, getMapping.value());
}

@Test
void getTrainer_shouldBeAnnotated() throws NoSuchMethodException {
    var getTrainer =
            TrainerController.class.getDeclaredMethod("getTrainer", String.class);
    var getMapping = getTrainer.getAnnotation(GetMapping.class);

    var pathVariableAnnotation = getTrainer.getParameters()[0].getAnnotation(PathVariable.class);

    assertNotNull(getMapping);
    assertArrayEquals(new String[]{"/{name}"}, getMapping.value());

    assertNotNull(pathVariableAnnotation);
}
----

Modifiez votre classe `TrainerController` pour faire passer les tests !

=== L'ex√©cution de notre projet !

Pour ex√©cuter notre projet, nous devons simplement lancer la classe `TrainerApi` √©crite plus haut.

Mais avant cela, modifions quelques propri√©t√©s de spring !

==== Personnalisation de Spring-Boot

Nous voulons un peu plus de logs pour bien comprendre ce que fait spring-boot.

Pour ce faire, nous allons monter le niveau de logs au niveau `TRACE`.

Cr√©er un fichier `application.properties` dans le r√©pertoire `src/main/resources`.

.src/main/resources/application.properties
[source,properties,linenums]
----
# on demande un niveau de logs TRACE a spring-web
logging.level.web=TRACE
# on modifie le port par defaut du tomcat !
server.port=8081
----

[NOTE]
Le r√©pertoire `src/main/resources` est ajout√© au classpath Java par IntelliJ, lors de l'ex√©cution, et par Maven lors
de la construction de notre jar !

La liste des properties support√©es est d√©crite dans la documentation de spring
https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html[ici,window="_blank"]

==== Ajout de donn√©es au d√©marrage

Comme notre application ne contient aucune donn√©e au d√©marrage, nous allons en charger quelques unes "en dur" pour commencer.

Ajoutez le code suivant dans la classe `TrainerApi` :

.src/main/java/com/ifi/trainers/TrainerApi.java
[source,java,linenums]
----
@Bean //<2>
@Autowired //<3>
public CommandLineRunner demo(TrainerRepository repository) { //<1>
    return (args) -> { //<4>
        var ash = new Trainer("Ash");
        var pikachu = new Pokemon(25, 18);
        ash.setTeam(List.of(pikachu));

        var misty = new Trainer("Misty");
        var staryu = new Pokemon(120, 18);
        var starmie = new Pokemon(121, 21);
        misty.setTeam(List.of(staryu, starmie));

        // save a couple of trainers
        repository.save(ash); //<5>
        repository.save(misty);
    };
}
----
<1> On impl√©mente un CommandLineRunner pour ex√©cuter des commandes au d√©marrage de notre application
<2> On utilise l‚Äôannotation @Bean sur notre m√©thode, pour en d√©clarer le retour comme √©tant un bean spring !
<3> On utilise l'injection de d√©pendance sur notre m√©thode !
<4> CommandLineRunner est une @FunctionnalInterface, on en fait une expression lambda.
<5> On initialise quelques donn√©es !

==== Ex√©cution

D√©marrez le main, et observez les logs (j'ai r√©duit la quantit√© de logs pour qu'elle s'affiche correctement ici) :

[source,text]
----
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )  <1>
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.1.2.RELEASE)

[main] [..] : Starting TrainerApi on jwittouck-N14xWU with PID 23154 (/home/jwittouck/workspaces/alom/alom-2020-2021/tp/trainer-api/target/classes started by jwittouck in /home/jwittouck/workspaces/alom/alom-2020-2021)
[main] [..] : No active profile set, falling back to default profiles: default
[main] [..] : Bootstrapping Spring Data repositories in DEFAULT mode.
[main] [..] : Finished Spring Data repository scanning in 47ms. Found 1 repository interfaces.
[main] [..] : Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$$ff9e9081] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
[main] [..] : Tomcat initialized with port(s): 8081 (http) <2>
[main] [..] : Starting service [Tomcat] <2>
[main] [..] : Starting Servlet engine: [Apache Tomcat/9.0.14]
[main] [..] : The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: [/usr/java/packages/lib:/usr/lib64:/lib64:/lib:/usr/lib]
[main] [..] : Initializing Spring embedded WebApplicationContext
[main] [..] : Published root WebApplicationContext as ServletContext attribute with name [org.springframework.web.context.WebApplicationContext.ROOT]
[main] [..] : Root WebApplicationContext: initialization completed in 1487 ms
[main] [..] : Added existing Servlet initializer bean 'dispatcherServletRegistration'; order=2147483647, resource=class path resource [org/springframework/boot/autoconfigure/web/servlet/DispatcherServletAutoConfiguration$DispatcherServletRegistrationConfiguration.class]
[main] [..] : Created Filter initializer for bean 'characterEncodingFilter'; order=-2147483648, resource=class path resource [org/springframework/boot/autoconfigure/web/servlet/HttpEncodingAutoConfiguration.class]
[main] [..] : Created Filter initializer for bean 'hiddenHttpMethodFilter'; order=-10000, resource=class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.class]
[main] [..] : Created Filter initializer for bean 'formContentFilter'; order=-9900, resource=class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.class]
[main] [..] : Created Filter initializer for bean 'requestContextFilter'; order=-105, resource=class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter.class]
[main] [..] : Mapping filters: characterEncodingFilter urls=[/*], hiddenHttpMethodFilter urls=[/*], formContentFilter urls=[/*], requestContextFilter urls=[/*]
[main] [..] : Mapping servlets: dispatcherServlet urls=[/]
[main] [..] : HikariPool-1 - Starting...
[main] [..] : HikariPool-1 - Start completed.
[main] [..] : HHH000204: Processing PersistenceUnitInfo [
	name: default
	...]
[main] [..] : HHH000412: Hibernate Core {5.3.7.Final} <3>
[main] [..] : HHH000206: hibernate.properties not found
[main] [..] : HCANN000001: Hibernate Commons Annotations {5.0.4.Final}
[main] [..] : HHH000400: Using dialect: org.hibernate.dialect.H2Dialect
[main] [..] : HHH000476: Executing import script 'org.hibernate.tool.schema.internal.exec.ScriptSourceInputNonExistentImpl@1ef93e01'
[main] [..] : Initialized JPA EntityManagerFactory for persistence unit 'default'
[main] [..] : Mapped [/**/favicon.ico] onto ResourceHttpRequestHandler [class path resource [META-INF/resources/], class path resource [resources/], class path resource [static/], class path resource [public/], ServletContext resource [/], class path resource []]
[main] [..] : Patterns [/**/favicon.ico] in 'faviconHandlerMapping'
[main] [..] : Initializing ExecutorService 'applicationTaskExecutor'
[main] [..] : ControllerAdvice beans: 0 @ModelAttribute, 0 @InitBinder, 1 RequestBodyAdvice, 1 ResponseBodyAdvice
[main] [..] : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
[main] [..] :
	c.m.a.t.t.c.TrainerController: <4>
	{GET /trainers/}: getAllTrainers()
	{GET /trainers/{name}}: getTrainer(String)
[main] [..] :
	o.s.b.a.w.s.e.BasicErrorController:
	{ /error, produces [text/html]}: errorHtml(HttpServletRequest,HttpServletResponse)
	{ /error}: error(HttpServletRequest)
[main] [..] : 4 mappings in 'requestMappingHandlerMapping'
[main] [..] : Detected 0 mappings in 'beanNameHandlerMapping'
[main] [..] : Mapped [/webjars/**] onto ResourceHttpRequestHandler ["classpath:/META-INF/resources/webjars/"]
[main] [..] : Mapped [/**] onto ResourceHttpRequestHandler ["classpath:/META-INF/resources/", "classpath:/resources/", "classpath:/static/", "classpath:/public/", "/"]
[main] [..] : Patterns [/webjars/**, /**] in 'resourceHandlerMapping'
[main] [..] : ControllerAdvice beans: 0 @ExceptionHandler, 1 ResponseBodyAdvice
[main] [..] : Tomcat started on port(s): 8081 (http) with context path ''
[main] [..] : Started TrainerApi in 3.622 seconds (JVM running for 4.512)

----
<1> Wao!
<2> On voit que un Tomcat est d√©marr√©, comme la derni√®re fois.
Mais cette fois-ci, il utilise bien le port `8081` comme demand√© dans le fichier `application.properties`
<3> Le nom `Hibernate` vous dit quelque chose? spring-data utilise hibernate comme impl√©mentation de la norme JPA !
<4> On voit √©galement nos controlleurs !

On peut maintenant tester les URLs suivantes:

* link:http://localhost:8081/trainers/[,window="_blank"]
* link:http://localhost:8081/trainers/Ash[,window="_blank"]

=== Le test d'int√©gration

Comme pour le TP pr√©c√©dent, nous allons compl√©ter nos d√©veloppements avec un test d'int√©gration.

Cr√©ez le test suivant:

.src/test/java/com/miage/alom/trainers/controller/TrainerControllerIntegrationTest.java
[source,java,linenums]
----
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class TrainerControllerIntegrationTest {

    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate restTemplate;

    @Autowired
    private TrainerController controller;

    @Test
    void trainerController_shouldBeInstanciated(){
        assertNotNull(controller);
    }

    @Test
    void getTrainer_withNameAsh_shouldReturnAsh() {
        var ash = this.restTemplate.getForObject("http://localhost:" + port + "/trainers/Ash", Trainer.class);
        assertNotNull(ash);
        assertEquals("Ash", ash.getName());
        assertEquals(1, ash.getTeam().size());

        assertEquals(25, ash.getTeam().get(0).getPokemonTypeId());
        assertEquals(18, ash.getTeam().get(0).getLevel());
    }

    @Test
    void getAllTrainers_shouldReturnAshAndMisty() {
        var trainers = this.restTemplate.getForObject("http://localhost:" + port + "/trainers/", Trainer[].class);
        assertNotNull(trainers);
        assertEquals(2, trainers.length);

        assertEquals("Ash", trainers[0].getName());
        assertEquals("Misty", trainers[1].getName());
    }
}
----

== Utilisation d'une base de donn√©es manag√©e sur le cloud public

Pour remplacer notre base de donn√©es embarqu√©e, nous pouvons nous connecter sur une base de donn√©es r√©elle, que nous allons
instancier sur un cloud public.

Pour ce faire, nous avons de nombreux clouds √† disposition, avec des offres gratuites :

* https://www.clever-cloud.com[clever-cloud] :
** clever-cloud (üá´üá∑) propose des bases de donn√©es postgresql manag√©es gratuites, pour une taille de 250Mo maximum, avec 5 connexions simultan√©es.
* https://aws.amazon.com/[AWS] (üá∫üá∏): le cloud d'Amazon
** Amazon propose des bases de donn√©es manag√©es via son service `RDS`. Ce service est disponible gratuitement pendant 12 mois √† compter de la
date de cr√©ation du compte, et dans la limite de 750 heures / mois (une carte bleue doit √™tre saisie)
* https://cloud.google.com/[GCP] (üá∫üá∏): le cloud de Google
** Google propose $300 de cr√©dits offerts √† l'inscription (une carte bleue doit √™tre saisie)
* https://www.heroku.com/[heroku] (üá∫üá∏):
** Heroku propose √©galement des bases de donn√©es postgresql manag√©es gratuites, dans la limite de 10 000 lignes, avec 10 connexions simultan√©es.

Pour ce TP, je prends l'exemple de clever-cloud, qui a aussi accept√© de nous sponsoriser en nous offrant une organisation avec des cr√©dits illimit√©s üôè.

=== clever-cloud

Cr√©ez un compte sur https://www.clever-cloud.com. Pour plus de facilit√©, vous pouvez tr√®s rapidement cr√©er votre compte en l'associant √† un compte Github.

==== Instanciation de la base de donn√©es

Une fois votre compte cr√©√©, vous pouvez instancier une base de donn√©es en quelques clics !

Dans la console, s√©lectionnez `Create > an add-on`.

image::images/clever-create.png[]

S√©lectionnez la base de donn√©es `postgresql`

image::images/clever-create-postgresql.png[]

S√©lectionnez le plan `DEV`, qui est gratuit
Donnez un nom √† votre base de donn√©es, et s√©lectionnez la r√©gion `Paris` (un h√©bergement de notre base de donn√©es √† Montr√©al
cr√©erait des temps de latence importants!)

image::images/clever-dev-free-plan.png[]
image::images/clever-naming-database.png[]

Validez, et attendez quelques secondes! Votre base de donn√©es est pr√™te!

Acc√©dez au dashboard de votre base de donn√©es. Vous pourrez y trouver:

* Les informations de connexion √† votre base de donn√©es
* Des menus permettant de r√©initialiser votre base, re-g√©n√©r√© de nouveaux identifiants de connexions, ou effectuer un backup.
* Vous pouvez √©galement acc√©der √† une interface "PGStudio" vous permettant de naviguer dans votre base de donn√©es.

.la page d'informations de votre base de donn√©es !
image::images/clever-database-information.png[]

=== Configuration pour spring-boot

Nous allons utiliser votre base de donn√©es nouvellement cr√©√©e pour votre application !

Modifiez votre `pom.xml` :

* Ajoutez une d√©pendance √† `postgresql` (qui contiendra le driver JDBC postgresql)
* On positionne cette d√©pendance en scope `runtime`, car ce driver n'est n√©cessaire qu'√† l'ex√©cution

.pom.xml
[source,xml,linenums]
----
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <scope>runtime</scope>
</dependency>
----

Modifiez votre fichier `application.properties` pour y renseigner les informations de connexion √† votre base de donn√©es :

.application.properties
[source,properties,linenums]
----
# utilisation de vos param√®tres de connexion <1>
spring.datasource.url=jdbc:postgresql://bae8fmg8aaq93hxlt9oa-postgresql.services.clever-cloud.com:5432/bae8fmg8aaq93hxlt9oa
spring.datasource.username=uavsnnvtbaqfme3yhamr
spring.datasource.password=rfeKGj4Vr6iExFDkVi0R

# personnalisation de hibernate <2>
spring.jpa.hibernate.ddl-auto = create-drop

# personnalisation du pool de connexions <3>
spring.datasource.hikari.maximum-pool-size=1
----
<1> Renseignez les param√®tre de connexion √† votre base de donn√©e (remplacez les valeurs de mon exemple)
<2> L'utilisation du param√®tre `spring.jpa.hibernate.ddl-auto` permet √† hibernate de g√©n√©rer le sch√©ma de base de donn√©es au d√©marrage de l'application.
<3> par d√©fault, spring-boot utilise le pool de connexion HikariCP pour g√©rer les connexions √† la base de donn√©es.
Comme le nombre de connexions est limit√© dans notre environnement, nous pr√©cisions que la taille maximale du pool est 1.

[WARNING]
====
Attention, la _Connection URI_ que clever-cloud vous affiche contient le login et le mot de passe d'acc√®s √† la base de donn√©es, et n'est pas une URL JDBC, ne la copiez pas!
Re-construisez votre URL JDBC en prenant les champs _Host_ et _Database Name_.
====

Pour rappel, la liste des propri√©t√©s accept√©es par spring-boot peut se trouver dans leur https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html[documentation,window="_blank"].

Le param√®tre `spring.jpa.hibernate.ddl-auto` peut prendre les valeurs suivantes :

* create : le sch√©ma est cr√©√© au d√©marrage de l'application, toutes les donn√©es existantes sont √©cras√©es
* create-drop : le sch√©ma est cr√©√© au d√©marrage de l'application, puis supprim√© √† son extinction (utile en d√©veloppement)
* update : le sch√©ma de la base de donn√©es est mis √† jour si n√©cessaire, les donn√©es ne sont pas impact√©es
* validate : le sch√©ma de la base de donn√©es est v√©rifi√© au d√©marrage

[TIP]
Dans IntelliJ, vous pouvez √©galement vous connecter √† votre base de donn√©es, utilisez le plugin `Database Tools & SQL`.

=== D√©ploiement chez Clever-Cloud !

WARNING: Pour cette partie, je dois vous donner les droits d'acc√®s √† l'organisation. Appelez moi pour que je puisse le faire avec vous !

NOTE: Ajoutez votre email associ√© √† votre compte Github dans ce formulaire: https://forms.gle/sRTiS3AzTWSDJ9eM7

==== Configuration de votre application

Clever-Cloud est capable d'ex√©cuter tout type d'applicaton.
Nous allons lui indiquer quel t√¢che maven appeler pour d√©marrer notre application.

Cr√©ez le fichier `maven.json` dans le r√©pertoire `clevercloud` de votre TP, pour lui indiquer d'utiliser la t√¢che maven `spring-boot:run` :

.clevercloud/maven.json
[source,json]
----
{
    "deploy": {
        "goal": "spring-boot:run"
    }
}

----

==== D√©ploiement

Sur le dashboard Clever-Cloud, dans l'organisation `Universit√© de Lille`, cliquez sur `Create... > an application`.

image::images/clever-cloud-new-application.png[]

De l√†, vous pouvez soit :
* s√©lectionner un repository Github existant
* cr√©er une application "Brand new". La suite de cette proc√©dure utilise cette option.

S√©lectionnez "Java + Maven"

image::images/clever-cloud-maven.png[]

image::images/clever-cloud-project-naming.png[]

Validez les √©crans.

Clever vous donne ensuite un remote git sur lequel vous pouvez push votre code pour le d√©ployer !


== Pour aller plus loin

* Impl√©mentez la cr√©ation et la mise √† jour d'un `Trainer` (route en POST/PUT) + Tests unitaires et tests d'int√©gration
----
POST /trainers/

{
  "name": "Bug Catcher",
  "team": [
    {"pokemonTypeId": 13, "level": 6},
    {"pokemonTypeId": 10, "level": 6}
  ]
}
----
* Impl√©mentez la suppression d'un `Trainer` (route en DELETE) + Tests unitaires et tests d'int√©gration
----
DELETE /trainers/Bug%20Catcher
----
